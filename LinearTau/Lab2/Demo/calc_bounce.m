% calc_bounce.m --- рассчитывает один отскок мяча от горизонтальной плоскости
% :z0 --- начальный вектор-строка состояния
% :t0 --- начальный момент времени
% :dzdt --- функция рассчета первой производной состояния z_dot = dzdt(t, z)
% Возвращаемые параметры:
% t --- вектор-столбец моментов времени моделирования
% z --- вектор-столбец векторов-строк состояний в процессе моделирования
% te --- момент времени, в который произошел удар
% ze --- состояние мяча в момент удара

% Сверху была справочная информация, отображаемая вызовом справки для этой
% функции.
% Файл-определение пользовательской функции
% Синтаксис тот же, что и у определения функции внутри файла скрипта,
% однако название файла с определением функции и самой функции должны
% совпадать
function [t, z, te, ze] = calc_bounce(z0, t0, dzdt)
% Краткая справка теперь не здесь, а в первой строке файла
t = [t0, t0 + 100];

% Создаем синоним функции event_zero_y, чтобы её можно было послать как
% аргумент
zero_y = @(t, z) event_zero_y(t,z);

% Магическая настройка моделирования:
% 'Events' говорит Matlab искать функцию, отслеживающую события, по имени
%          zero_y
% 'MaxStep' говорит, что при моделировании нельзя поднимать шаг
% интегрирования выше 10^-4 == 1e-4
opt = odeset('Events', zero_y, "MaxStep",1e-4);

% Встроенная функция Matlab, проводящая моделирование системы с функцией
% произодных dzdt, в течение промежутка времени t, с начальными условиями
% z0 и настройками opt
[t, z, te, ze, ie] = ode45(dzdt, t, z0, opt);
end % <--- Окончание определения функции


% Определение функции, внутренней для функции, определяемой в отдельном
% файле. Скрипт bouncer.m не узнает о существовании event_zero_y, однако
% она доступна с этом файле.
% Для того, чтобы эта функция могла быть использована в ode45, она должна
% иметь определенный заранее (см. документацию на odeset) вид
function [value, isterminal, direction] = event_zero_y(t, z) 
% event_zero_y --- checks if ball is hitting the ground

% value присваивается булево выражение
value = (abs(z(2,1)) < 1e-2) && (z(4,1) < 0);
% isterminal == 1 --- остановить симуляцию, если value ~= 0
isterminal = 1;
% direction --- параметр, отвечающий за направление перескока через
% value == 0, нам не интересен, но нужен согласно документации
direction = 0;
end